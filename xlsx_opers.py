from initials_common import file_paths, file_mask, needed, titles, etalon, reports

from file_opers import archive_files
from txt_opers import writing_etalon, log_write

from datetime import datetime as dt, time
from openpyxl import Workbook as wkb, load_workbook as ld_wb
from pathlib import Path


# Функция подготовки строчного представления переменной «etalon» для записи ее в инициализационный файл
# (собственно, выполняется разбивка на строки заданной длины, для соответствия стандартам python по длине строк)
def format_etalon_string(captions):
    # Инициализируем переменную, указывающую количество отступов для файла отчета
    indention = 8
    # Инициализируем пустой массив строк
    etalon_str = ['']
    # Инициализируем счетчик элементов массива
    i = 0
    # Для всех элементов в переданном при вызове функции массиве, содержащем новые эталонные заголовки
    for item in captions:
        # Формируем строку - текущий элемент массива строк
        etalon_str[i] += "'" + item + "', "
        # Если длина текущей строки превышает 80 символов и это не последний элемент массива с эталонными
        # заголовками
        if len(etalon_str[i]) > 80 and captions.index(item) < len(captions) - 1:
            # Увеличиваем счетчик элементов массива на 1 (переходим к следующей строке массива строк)
            i += 1
            # Добавляем новый элемент, начинающийся с 12 пробелов (для отступа) в массив строк
            etalon_str.append(" " * 12)
    # Удаляем запятую и пробел в конце последней строки массива строк
    etalon_str[i] = etalon_str[i][:-2]
    # Инициализируем переменную для добавления переноса строки в форматированный текст
    new_line = '\n'
    # Возвращаем массив captions в виде строк, разбитых символами переноса строки по длине
    log_write(f'Формирование строкового представления переменной «etalon» завершено', indention)
    return f'etalon = [{new_line.join(etalon_str)}]\n'


# Процедура, проставляющаяя номера колонок в массиве needed_pos, соответствующие заголовкам требуемых нам
# для отчетов столбцов из массива needed
def remap_positions(captions):
    # Инициализируем переменную, указывающую количество отступов для файла отчета
    indention = 8
    # Объявляем глобальную переменную needed_pos для возможности ее изменения
    global needed_pos

    # Перебираем все элементы массива captions
    for i in range(len(captions)):
        # Инициализируем временную переменную для хранения названия текущего столбца
        tmp_var = captions[i]
        # Если в массиве needed существует ячейка с названием как у текущего столбца
        if tmp_var in needed:
            # Присваиваем элементу массива needed_pos с индексом, соответствующим индексу элемента
            # массива needed со значением как у текущего столбца номер этого столбца
            needed_pos[needed.index(tmp_var)] = i
    log_write(f'Процедура переназначения номеров столбцов успешно завершена', indention)


# Функция проверки соответствия структуры файла эталонной или наличия необходимых полей в файле и изменения
# глобальной переменной «etalon» при наличии изменения в структуре
def file_structure_check(file, row):
    # Инициализируем переменную, указывающую количество отступов для файла отчета
    indention = 6
    # Инициализируем глобальную переменную «etalon» для возможности ее изменения
    global etalon

    # Создаем массив значений ячеек из переданной при вызове функции строки из xlsx файла
    captions = list(i.value for i in row)
    # Если переданная строка не соответствует эталону
    if etalon != captions:
        # Проверяем наличие в ней необходимых для отчета полей
        if set(needed).issubset(set(captions)):
            # Если в переданной строке есть необходимые для отчета поля, считаем изменения некритичными
            log_write(f'Некритичные изменения структуры файла выгрузки {file}', indention)
            # Переписываем строку с переменной «etalon» в инициализационном файле
            log_write(f'Процедура перезаписи переменной «etalon» в инициализационном файле', indention)
            writing_etalon(format_etalon_string(captions))
            log_write(f'Переменная «etalon» в инициализационном файле успешно изменена', indention)
            # Присваиваем переменной «etalon» новое значение из строки, переданной при вызове функции
            etalon = captions
        else:
            # Если в переданной строке отсутствуют поля необходимые для отчета,
            # считаем изменения критичными
            log_write(f'ВНИМАНИЕ!!! Критичные изменения структуры файла выгрузки {file}. \n'
                      f'Работа программы будет завершена. Требуется вмешательство для ручного анализа '
                      f'изменений.', indention)
            # Завершаем работу программы для ручного анализа изменений
            exit(-1)

    # Проставляем номера колонок в массиве needed_pos, соответствующие заголовкам требуемых нам для отчетов
    # столбцов из массива needed
    log_write(f'Процедура переназначения номеров столбцов для соответствия заголовкам отчетов', indention)
    remap_positions(captions)


# Функция подготовки строк из xlsx файлов отчетов для добавления их в БД
def prepare_strings():
    # Инициализируем переменную, указывающую количество отступов для файла отчета
    indention = 4
    # Инициализируем глобальную переменную для возможности внесения в нее изменений
    global needed_pos
    # Заполняем массив из десяти элементов значениями -1
    needed_pos = [-1] * 10
    # Получаем список всех файлов выгрузок
    paths = list(Path(file_paths).glob(file_mask))
    log_write(f'Получен список из {len(paths)} файлов выгрузок', indention)
    # Инициализируем общий счетчик строк файла и счетчик добавленных строк
    str_total, str_added = 0, 0
    # Инициализируем пустой массив строк для передачи из в вызывающую функцию
    curr_sheet = []
    # Перебираем все файлы в списке файлов выгрузок
    for file in paths:
        # Открываем текущий файл
        wb = ld_wb(filename=file)
        log_write(f'Открыт файл {file}', indention)
        # Выбираем первый лист рабочей книги
        sheet = wb.worksheets[0]
        log_write(f'Выбран лист {sheet.title}', indention)
        # Проверяем структуру текущего файла по заголовкам, содержащимся во второй строке
        log_write(f'Проверяем структуру файла', indention)
        file_structure_check(file, sheet[2])
        log_write(f'Структура файла успешно проверена', indention)
        # Обнуляем общий счетчик строк файла и счетчик добавленных строк
        str_total, str_added = 0, 0
        # Читаем все строки листа
        for row in sheet.rows:
            # Увеличиваем на единицу общий счетчик строк файла
            str_total += 1
            # Нас интересуют только строки, где в первом столбце стоит целое число - номер трупа
            if type(row[needed_pos[0]].value) == int:
                # Увеличиваем на единицу счетчик добавленных строк
                str_added += 1
                # Инициализируем пустой массив для хранения текущей строки
                curr_row = []
                # Перебираем только нужные нам ячейки из текущей строки
                for cell_num in needed_pos:
                    # Создаем временную переменную для хранения значения текущей ячейки
                    tmp_val = row[cell_num].value
                    # Если тип значения ячейки дата
                    if type(tmp_val) == dt:
                        # Если время в дате установлено 00:00:00
                        if tmp_val.time() == time(0, 0, 0):
                            # Конвертируем временную переменную в строку в формате ДД.ММ.ГГГГ для соответствия
                            # ранее введенным датам
                            tmp_val = tmp_val.strftime("%d.%m.%Y")
                        # Если время в дате не равно нулю
                        else:
                            # Конвертируем временную переменную в строку в формате ДД.ММ.ГГГГ ЧЧ:ММ для соответствия
                            # ранее введенным датам
                            tmp_val = tmp_val.strftime("%d.%m.%Y %H:%M")
                    # Дописываем в массив, содержащий текущую строку значение текущей ячейки
                    curr_row.append(tmp_val)
                # Дописываем в массив строк текущую строку
                curr_sheet.append(curr_row)
        log_write(f'Прочитано {str_total} строк, добавлено {str_added} строк', indention)
    log_write(f'Обработано {len(paths)} файлов', indention)
    # Вызываем процедуру архивирования и удаления xlsx файлов выгрузок
    log_write(f'Процедура архивирования и удаления файлов', indention)
    archive_files(paths)
    # Возвращаем массив строк для добавления их в БД
    return curr_sheet


# Процедура записи листов с данными в xlsx файл итогового отчета
def save_xlsx(xlsx_filename, report_name, strings_to_add):
    # Инициализируем переменную, указывающую количество отступов для файла отчета
    indention = 4
    # Если вызывается первый по списку отчет, считаем, что xlsx файла итогового отчета еще не существует
    if report_name == reports[0]:
        # Создаем рабочую книгу
        wb_w = wkb()
        log_write(f'Рабочая книга {xlsx_filename} создана', indention)
        # Создаем первый лист в рабочей книге
        sheet_w = wb_w.worksheets[0]
        # Переименовываем лист, соответсвенно названию отчета
        sheet_w.title = report_name
        log_write(f'Лист {report_name} создан', indention)
    # Если вызывается не первый отчет из списка, считаем, что xlsx файла итогового отчета уже существует
    else:
        # Открываем рабочую книгу из имени файла, переданном при вызове процедуры
        wb_w = ld_wb(filename=xlsx_filename)
        log_write(f'Рабочая книга {xlsx_filename} успешно открыта', indention)
        # Добавляем новый лист с именем, соответсвующим названию отчета, в рабочую книгу
        sheet_w = wb_w.create_sheet(report_name)
        log_write(f'Лист {report_name} создан', indention)

    # Берем заголовки столбцов из массива «reports», учитывая, что для первого и третьего отчета заголовки
    # одинаковые, и содержатся в нулевом элементе массива «reports»
    pos_titles = 1 if report_name == reports[1] else 0
    # Добавляем строку с названиями столбцов на текущий лист
    sheet_w.append(titles[pos_titles])
    log_write(f'На лист добавлена строка с названиями столбцов', indention)
    # Для каждой строки из переданного при вызове процедуры массива
    for row in strings_to_add:
        # Добавляем строку на текущий лист
        sheet_w.append(row)
    log_write(f'На лист {report_name} добавлено {len(strings_to_add)} строк данных', indention)

    # Сохраняем xlsx файл итогового отчета с именем, преданным при вызове функции
    wb_w.save(xlsx_filename)
    log_write(f'Рабочая книга {xlsx_filename} с добавленным листом {report_name} успешно сохранена', indention)
